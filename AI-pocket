#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <Preferences.h>
#include <esp_sleep.h>
#include <esp_system.h>

// OLED Display settings
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
#define SCREEN_ADDRESS 0x3C
#define SDA_PIN 20
#define SCL_PIN 21
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Button pins
#define BTN_UP 5
#define BTN_DOWN 6
#define BTN_LEFT 3
#define BTN_RIGHT 4
#define BTN_SELECT 9

// LED Built-in
#define LED_BUILTIN 8

// Battery monitoring
#define BATTERY_PIN 0
#define CHARGING_PIN 1
#define BATTERY_MAX_VOLTAGE 4.2
#define BATTERY_MIN_VOLTAGE 3.3
#define VOLTAGE_DIVIDER_RATIO 2.0

// Dual Gemini API Keys
const char* geminiApiKey1 = "AIzaSyAtKmbcvYB8wuHI9bqkOhufJld0oSKv7zM"; // <-- API KEY 1
const char* geminiApiKey2 = "AIzaSyBvXPx3SrrRRJIU9Wf6nKcuQu9XjBlSH6Y"; // <-- API KEY 2

const char* geminiEndpoint = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent";

Preferences preferences;

// WiFi Scanner
struct WiFiNetwork {
  String ssid;
  int rssi;
  bool encrypted;
};
WiFiNetwork networks[20];
int networkCount = 0;
int selectedNetwork = 0;

// WiFi Auto-off settings
unsigned long lastWiFiActivity = 0;
const unsigned long wifiTimeout = 300000; // 5 menit
bool wifiAutoOffEnabled = false;

// Calculator
String calcDisplay = "0";
String calcNumber1 = "";
char calcOperator = ' ';
bool calcNewNumber = true;

// Battery monitoring
float batteryVoltage = 0.0;
int batteryPercent = 100;
bool isCharging = false;
unsigned long lastBatteryCheck = 0;
const unsigned long batteryCheckInterval = 2000;

// Power history
#define POWER_HISTORY_SIZE 50
int batteryHistory[POWER_HISTORY_SIZE];
int historyIndex = 0;
bool historyFilled = false;
unsigned long lastHistoryUpdate = 0;

// System stats
uint32_t freeHeap = 0;
uint32_t totalHeap = 0;
uint32_t minFreeHeap = 0;
float cpuFreq = 0;
uint32_t loopCount = 0;
unsigned long lastLoopCount = 0;
unsigned long lastLoopTime = 0;

int loadingFrame = 0;
unsigned long lastLoadingUpdate = 0;

int selectedAPIKey = 1;

// Keyboard layouts
const char* keyboardLower[3][10] = {
  {"q", "w", "e", "r", "t", "y", "u", "i", "o", "p"},
  {"a", "s", "d", "f", "g", "h", "j", "k", "l", "<"},
  {"#", "z", "x", "c", "v", "b", "n", "m", " ", "OK"}
};

const char* keyboardUpper[3][10] = {
  {"Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"},
  {"A", "S", "D", "F", "G", "H", "J", "K", "L", "<"},
  {"#", "Z", "X", "C", "V", "B", "N", "M", ".", "OK"}
};

const char* keyboardNumbers[3][10] = {
  {"1", "2", "3", "4", "5", "6", "7", "8", "9", "0"},
  {"!", "@", "#", "$", "%", "^", "&", "*", "(", ")"},
  {"#", "-", "_", "=", "+", "[", "]", "?", ".", "OK"}
};

enum KeyboardMode {
  MODE_LOWER,
  MODE_UPPER,
  MODE_NUMBERS
};
KeyboardMode currentKeyboardMode = MODE_LOWER;

enum AppState {
  STATE_WIFI_MENU,
  STATE_WIFI_SCAN,
  STATE_PASSWORD_INPUT,
  STATE_KEYBOARD,
  STATE_CHAT_RESPONSE,
  STATE_MAIN_MENU,
  STATE_CALCULATOR,
  STATE_POWER_BASE,
  STATE_POWER_VISUAL,
  STATE_POWER_STATS,
  STATE_POWER_GRAPH,
  STATE_API_SELECT,
  STATE_SYSTEM_INFO,
  STATE_SETTINGS_MENU,
  STATE_SLEEP_MENU,
  STATE_LOADING
};

AppState currentState = STATE_MAIN_MENU;

int cursorX = 0, cursorY = 0;
String userInput = "";
String passwordInput = "";
String selectedSSID = "";
String aiResponse = "";
int scrollOffset = 0;
int menuSelection = 0;
unsigned long lastDebounce = 0;
const unsigned long debounceDelay = 200;
int powerMenuSelection = 0;
int settingsMenuSelection = 0;

// Progress bar
int progressPercent = 0;

// LED Patterns
void ledHeartbeat() {
  int beat = (millis() / 100) % 20;
  digitalWrite(LED_BUILTIN, (beat < 2 || beat == 4));
}

void ledPulse() {
  int pulse = (millis() / 10) % 512;
  if (pulse > 255) pulse = 511 - pulse;
  analogWrite(LED_BUILTIN, pulse);
}

void ledBlink(int speed) {
  digitalWrite(LED_BUILTIN, (millis() / speed) % 2);
}

void ledBreathing() {
  int breath = (millis() / 20) % 512;
  if (breath > 255) breath = 511 - breath;
  analogWrite(LED_BUILTIN, breath);
}

void ledSuccess() {
  for (int i = 0; i < 3; i++) {
    digitalWrite(LED_BUILTIN, HIGH);
    delay(100);
    digitalWrite(LED_BUILTIN, LOW);
    delay(100);
  }
}

void ledError() {
  for (int i = 0; i < 5; i++) {
    digitalWrite(LED_BUILTIN, HIGH);
    delay(80);
    digitalWrite(LED_BUILTIN, LOW);
    delay(80);
  }
}

void ledQuickFlash() {
  digitalWrite(LED_BUILTIN, HIGH);
  delay(30);
  digitalWrite(LED_BUILTIN, LOW);
}

// Forward declarations
void showMainMenu();
void showWiFiMenu();
void showCalculator();
void showPowerBase();
void showPowerVisual();
void showPowerStats();
void showPowerGraph();
void showAPISelect();
void showSystemInfo();
void showSettingsMenu();
void showSleepMenu();
void showLoadingAnimation();
void showProgressBar(String title, int percent);
void displayWiFiNetworks();
void drawKeyboard();
void handleMainMenuSelect();
void handleWiFiMenuSelect();
void handlePowerBaseSelect();
void handleAPISelectSelect();
void handleSettingsMenuSelect();
void handleKeyPress();
void handlePasswordKeyPress();
void handleCalculatorInput();
void connectToWiFi(String ssid, String password);
void scanWiFiNetworks();
void displayResponse();
void showStatus(String message, int delayMs);
void forgetNetwork();
void refreshCurrentScreen();
void calculateResult();
void resetCalculator();
void updateBatteryLevel();
void updatePowerHistory();
void updateSystemStats();
void drawBatteryIndicator();
void drawWiFiSignalBars();
void drawChargingPlug();
void sendToGemini();
void checkWiFiTimeout();
void enterDeepSleep();
const char* getCurrentKey();
void toggleKeyboardMode();

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n=== ESP32-C3 Ultra Edition v7.0 ===");
  Serial.println("Advanced Features Enabled");
  
  // Check wake-up reason
  esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();
  if (wakeup_reason == ESP_SLEEP_WAKEUP_EXT0) {
    Serial.println("Wake up from deep sleep!");
  }
  
  preferences.begin("wifi-creds", false);
  preferences.begin("settings", false);
  Wire.begin(SDA_PIN, SCL_PIN);
  
  pinMode(BTN_UP, INPUT_PULLUP);
  pinMode(BTN_DOWN, INPUT_PULLUP);
  pinMode(BTN_LEFT, INPUT_PULLUP);
  pinMode(BTN_RIGHT, INPUT_PULLUP);
  pinMode(BTN_SELECT, INPUT_PULLUP);
  
  // Setup wake-up from deep sleep
 esp_sleep_enable_gpio_wakeup();
 gpio_wakeup_enable((gpio_num_t)BTN_SELECT, GPIO_INTR_LOW_LEVEL);
  
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);
  
  pinMode(BATTERY_PIN, INPUT);
  pinMode(CHARGING_PIN, INPUT);
  analogReadResolution(12);
  analogSetAttenuation(ADC_11db);
  updateBatteryLevel();
  
  for (int i = 0; i < POWER_HISTORY_SIZE; i++) {
    batteryHistory[i] = batteryPercent;
  }
  
  // Load settings
  wifiAutoOffEnabled = preferences.getBool("wifiAutoOff", false);
  
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }
  
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.display();
  
  ledSuccess();
  
  String savedSSID = preferences.getString("ssid", "");
  String savedPassword = preferences.getString("password", "");
  
  if (savedSSID.length() > 0) {
    showProgressBar("WiFi Connect", 0);
    WiFi.begin(savedSSID.c_str(), savedPassword.c_str());
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 20) {
      ledBlink(100);
      delay(500);
      attempts++;
      showProgressBar("Connecting", attempts * 5);
    }
    
    if (WiFi.status() == WL_CONNECTED) {
      ledSuccess();
      showProgressBar("Connected!", 100);
      delay(1000);
      lastWiFiActivity = millis();
    } else {
      ledError();
      showStatus("Connection failed\nOpening WiFi menu", 2000);
      currentState = STATE_WIFI_MENU;
    }
  } else {
    currentState = STATE_WIFI_MENU;
  }
  
  updateSystemStats();
  showMainMenu();
}

void loop() {
  unsigned long currentMillis = millis();
  
  loopCount++;
  
  if (currentMillis - lastBatteryCheck > batteryCheckInterval) {
    updateBatteryLevel();
    lastBatteryCheck = currentMillis;
    if (currentState != STATE_LOADING) {
      refreshCurrentScreen();
    }
  }
  
  if (currentMillis - lastHistoryUpdate > 10000) {
    updatePowerHistory();
    lastHistoryUpdate = currentMillis;
  }
  
  if (currentMillis - lastLoopTime > 1000) {
    lastLoopCount = loopCount;
    loopCount = 0;
    lastLoopTime = currentMillis;
    updateSystemStats();
  }
  
  // Check WiFi timeout
  if (wifiAutoOffEnabled && WiFi.status() == WL_CONNECTED) {
    checkWiFiTimeout();
  }
  
  // Interactive LED Patterns
  switch(currentState) {
    case STATE_LOADING:
      ledPulse();
      break;
    case STATE_CHAT_RESPONSE:
      ledBreathing();
      break;
    case STATE_CALCULATOR:
      ledBlink(500);
      break;
    case STATE_POWER_BASE:
    case STATE_POWER_VISUAL:
    case STATE_POWER_STATS:
    case STATE_POWER_GRAPH:
      if (isCharging) {
        ledPulse();
      } else if (batteryPercent < 20) {
        ledBlink(250);
      } else if (batteryPercent < 50) {
        ledBlink(1000);
      } else {
        ledBreathing();
      }
      break;
    case STATE_SYSTEM_INFO:
      // Rainbow-like pattern for system info
      {
        int rainbow = (millis() / 100) % 30;
        digitalWrite(LED_BUILTIN, rainbow < 10 || (rainbow > 14 && rainbow < 20));
      }
      break;
    case STATE_SLEEP_MENU:
      // Slow fade for sleep menu
      {
        int fade = (millis() / 50) % 256;
        if (fade > 128) fade = 255 - fade;
        analogWrite(LED_BUILTIN, fade / 2);
      }
      break;
    case STATE_KEYBOARD:
    case STATE_PASSWORD_INPUT:
      ledBlink(300);
      break;
    case STATE_WIFI_SCAN:
    case STATE_WIFI_MENU:
      if (WiFi.status() == WL_CONNECTED) {
        ledBlink(800);
      } else {
        ledBlink(200);
      }
      break;
    case STATE_API_SELECT:
      {
        int pattern = (millis() / 150) % 8;
        digitalWrite(LED_BUILTIN, pattern < 2 || (pattern > 3 && pattern < 6));
      }
      break;
    case STATE_MAIN_MENU:
    default:
      ledHeartbeat();
      break;
  }
  
  if (currentState == STATE_LOADING) {
    if (currentMillis - lastLoadingUpdate > 100) {
      lastLoadingUpdate = currentMillis;
      loadingFrame = (loadingFrame + 1) % 8;
      showLoadingAnimation();
    }
  }
  
  if (currentMillis - lastDebounce > debounceDelay) {
    bool buttonPressed = false;
    
    if (digitalRead(BTN_UP) == LOW) {
      handleUp();
      buttonPressed = true;
    }
    if (digitalRead(BTN_DOWN) == LOW) {
      handleDown();
      buttonPressed = true;
    }
    if (digitalRead(BTN_LEFT) == LOW) {
      handleLeft();
      buttonPressed = true;
    }
    if (digitalRead(BTN_RIGHT) == LOW) {
      handleRight();
      buttonPressed = true;
    }
    if (digitalRead(BTN_SELECT) == LOW) {
      handleSelect();
      buttonPressed = true;
    }
    
    if (buttonPressed) {
      lastDebounce = currentMillis;
      ledQuickFlash();
      if (WiFi.status() == WL_CONNECTED) {
        lastWiFiActivity = currentMillis;
      }
    }
  }
}

// ========== SYSTEM INFO ==========

void updateSystemStats() {
  freeHeap = ESP.getFreeHeap();
  totalHeap = ESP.getHeapSize();
  minFreeHeap = ESP.getMinFreeHeap();
  cpuFreq = ESP.getCpuFreqMHz();
}

void showSystemInfo() {
  display.clearDisplay();
  
  display.setTextSize(1);
  display.setCursor(10, 2);
  display.print("== SYSTEM INFO ==");
  
  display.drawLine(0, 12, SCREEN_WIDTH, 12, SSD1306_WHITE);
  
  // Memory info
  display.setCursor(2, 15);
  display.print("Free Heap:");
  display.setCursor(70, 15);
  display.print(freeHeap / 1024);
  display.print(" KB");
  
  display.setCursor(2, 24);
  display.print("Total Heap:");
  display.setCursor(70, 24);
  display.print(totalHeap / 1024);
  display.print(" KB");
  
  display.setCursor(2, 33);
  display.print("Min Free:");
  display.setCursor(70, 33);
  display.print(minFreeHeap / 1024);
  display.print(" KB");
  
  // CPU info
  display.setCursor(2, 42);
  display.print("CPU Freq:");
  display.setCursor(70, 42);
  display.print((int)cpuFreq);
  display.print(" MHz");
  
  // Loop rate
  display.setCursor(2, 51);
  display.print("Loop/sec:");
  display.setCursor(70, 51);
  display.print(lastLoopCount);
  
  // Progress bar for heap usage
  int heapUsed = 100 - ((freeHeap * 100) / totalHeap);
  display.drawRect(2, 58, SCREEN_WIDTH - 4, 5, SSD1306_WHITE);
  int barWidth = map(heapUsed, 0, 100, 0, SCREEN_WIDTH - 6);
  display.fillRect(3, 59, barWidth, 3, SSD1306_WHITE);
  
  display.display();
}

// ========== SETTINGS MENU ==========

void showSettingsMenu() {
  display.clearDisplay();
  drawBatteryIndicator();
  
  display.setTextSize(1);
  display.setCursor(15, 2);
  display.print("== SETTINGS ==");
  
  const char* menuItems[] = {
    "WiFi Auto-Off",
    "System Info",
    "Sleep Mode",
    "Back"
  };
  
  for (int i = 0; i < 4; i++) {
    display.setCursor(5, 20 + i * 10);
    if (i == settingsMenuSelection) {
      display.print("> ");
    } else {
      display.print("  ");
    }
    display.print(menuItems[i]);
    
    // Show status for WiFi Auto-Off
    if (i == 0) {
      display.setCursor(95, 20 + i * 10);
      if (wifiAutoOffEnabled) {
        display.print("[ON]");
      } else {
        display.print("[OFF]");
      }
    }
  }
  
  display.display();
}

void handleSettingsMenuSelect() {
  switch(settingsMenuSelection) {
    case 0: // Toggle WiFi Auto-Off
      wifiAutoOffEnabled = !wifiAutoOffEnabled;
      preferences.putBool("wifiAutoOff", wifiAutoOffEnabled);
      ledSuccess();
      if (wifiAutoOffEnabled) {
        lastWiFiActivity = millis();
        showStatus("WiFi Auto-Off\nENABLED", 1500);
      } else {
        showStatus("WiFi Auto-Off\nDISABLED", 1500);
      }
      showSettingsMenu();
      break;
    case 1: // System Info
      currentState = STATE_SYSTEM_INFO;
      showSystemInfo();
      break;
    case 2: // Sleep Mode
      currentState = STATE_SLEEP_MENU;
      showSleepMenu();
      break;
    case 3: // Back
      currentState = STATE_MAIN_MENU;
      menuSelection = 0;
      showMainMenu();
      break;
  }
}

// ========== SLEEP MODE ==========

void showSleepMenu() {
  display.clearDisplay();
  
  display.setTextSize(1);
  display.setCursor(15, 10);
  display.print("== SLEEP MODE ==");
  
  display.setCursor(10, 25);
  display.print("Enter Deep Sleep?");
  
  display.setCursor(5, 40);
  display.print("Battery: ");
  display.print(batteryPercent);
  display.print("%");
  
  display.setCursor(5, 50);
  display.print("Press SELECT to sleep");
  
  // Animated moon icon
  int moonX = 100;
  int moonY = 25;
  int moonPhase = (millis() / 500) % 8;
  
  display.drawCircle(moonX, moonY, 8, SSD1306_WHITE);
  if (moonPhase < 4) {
    display.fillCircle(moonX + 3, moonY, 6, SSD1306_BLACK);
  } else {
    display.fillCircle(moonX - 3, moonY, 6, SSD1306_BLACK);
  }
  
  display.display();
}

void enterDeepSleep() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(20, 20);
  display.print("Going to sleep");
  
  for (int i = 0; i < 3; i++) {
    display.print(".");
    display.display();
    delay(300);
  }
  
  display.clearDisplay();
  display.setCursor(15, 25);
  display.print("Good night! Zzz");
  display.display();
  
  // LED fadeout
  for (int i = 255; i >= 0; i -= 5) {
    analogWrite(LED_BUILTIN, i);
    delay(10);
  }
  
  delay(1000);
  
  // Turn off display
  display.clearDisplay();
  display.display();
  
  // Disconnect WiFi
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);
  
  Serial.println("Entering deep sleep...");
  Serial.flush();
  
  // Enter deep sleep
  esp_deep_sleep_start();
}

// ========== WIFI TIMEOUT ==========

void checkWiFiTimeout() {
  if (millis() - lastWiFiActivity > wifiTimeout) {
    WiFi.disconnect(true);
    WiFi.mode(WIFI_OFF);
    showStatus("WiFi Auto-Off\nTimeout reached", 2000);
    showMainMenu();
  }
}

// ========== PROGRESS BAR ==========

void showProgressBar(String title, int percent) {
  display.clearDisplay();
  
  display.setTextSize(1);
  int titleW = title.length() * 6;
  display.setCursor((SCREEN_WIDTH - titleW) / 2, 15);
  display.print(title);
  
  // Progress bar
  int barX = 10;
  int barY = 30;
  int barW = SCREEN_WIDTH - 20;
  int barH = 12;
  
  display.drawRect(barX, barY, barW, barH, SSD1306_WHITE);
  
  int fillW = map(percent, 0, 100, 0, barW - 4);
  display.fillRect(barX + 2, barY + 2, fillW, barH - 4, SSD1306_WHITE);
  
  // Percentage text
  display.setCursor(55, 47);
  display.print(percent);
  display.print("%");
  
  display.display();
}

void updatePowerHistory() {
  batteryHistory[historyIndex] = batteryPercent;
  historyIndex = (historyIndex + 1) % POWER_HISTORY_SIZE;
  if (historyIndex == 0) historyFilled = true;
}

void showPowerBase() {
  display.clearDisplay();
  
  int pulse = (millis() / 150) % 10;
  if (pulse > 5) pulse = 10 - pulse;
  
  display.setTextSize(1);
  display.setCursor(10 + pulse / 3, 2);
  display.print("< POWER CENTRAL >");
  
  const char* menuItems[] = {
    "1. Battery Visual",
    "2. Statistics",
    "3. Power Graph",
    "4. Back"
  };
  
  for (int i = 0; i < 4; i++) {
    display.setCursor(5, 20 + i * 10);
    if (i == powerMenuSelection) {
      display.print("> ");
      if ((millis() / 200) % 2 == 0) {
        display.fillRect(122, 20 + i * 10, 4, 8, SSD1306_WHITE);
      }
    } else {
      display.print("  ");
    }
    display.print(menuItems[i]);
  }
  
  display.display();
}

void showPowerVisual() {
  display.clearDisplay();
  
  int headerAnim = (millis() / 200) % 3;
  display.setTextSize(1);
  display.setCursor(15 + headerAnim, 1);
  display.print("BATTERY VISUAL");
  
  int battX = 20;
  int battY = 14;
  int battW = 70;
  int battH = 36;
  
  display.fillRect(battX + 2, battY + 2, battW, battH, SSD1306_WHITE);
  display.fillRect(battX, battY, battW, battH, SSD1306_BLACK);
  
  display.drawRect(battX, battY, battW, battH, SSD1306_WHITE);
  display.drawRect(battX + 1, battY + 1, battW - 2, battH - 2, SSD1306_WHITE);
  
  display.fillRect(battX + battW, battY + 13, 7, 10, SSD1306_WHITE);
  display.drawRect(battX + battW, battY + 13, 7, 10, SSD1306_WHITE);
  display.drawRect(battX + battW + 1, battY + 14, 5, 8, SSD1306_BLACK);
  
  int fillW = map(batteryPercent, 0, 100, 0, battW - 10);
  
  if (isCharging) {
    int waveSpeed = (millis() / 60) % 30;
    
    for (int i = 0; i < fillW; i++) {
      int wave = abs(((i - waveSpeed) % 30) - 15);
      if (wave < 8) {
        int height = map(wave, 0, 8, battH - 10, 4);
        display.drawLine(battX + 5 + i, battY + 5, 
                        battX + 5 + i, battY + 5 + height, SSD1306_WHITE);
      }
    }
    
    int boltX = battX + battW/2 - 6;
    int boltY = battY + battH/2 - 10;
    int boltAnim = (millis() / 150) % 3;
    
    if (boltAnim > 0) {
      display.fillTriangle(boltX + 6, boltY, boltX, boltY + 10, boltX + 6, boltY + 10, SSD1306_BLACK);
      display.fillTriangle(boltX + 6, boltY + 10, boltX + 12, boltY + 20, boltX + 6, boltY + 20, SSD1306_BLACK);
      
      if (boltAnim == 2) {
        display.drawCircle(boltX + 6, boltY + 10, 8, SSD1306_WHITE);
      }
    }
    
    int particleCount = 8;
    for (int i = 0; i < particleCount; i++) {
      int particlePhase = (millis() / 100 + i * 30) % 360;
      int particleX = battX + 10 + (particlePhase * (battW - 20) / 360);
      int particleY = battY + 8 + random(battH - 16);
      
      if (particlePhase < 180) {
        display.fillCircle(particleX, particleY, 1, SSD1306_WHITE);
      }
    }
    
  } else {
    int segments = 7;
    int segmentWidth = (battW - 10) / segments;
    
    for (int i = 0; i < segments; i++) {
      int segX = battX + 5 + (i * segmentWidth);
      int segFillW = min(segmentWidth - 2, fillW - (i * segmentWidth));
      
      if (segFillW > 0) {
        for (int y = 0; y < battH - 10; y += 2) {
          display.drawLine(segX, battY + 5 + y, 
                          segX + segFillW, battY + 5 + y, SSD1306_WHITE);
        }
      }
    }
  }
  
  display.setTextSize(2);
  String percentText = String(batteryPercent) + "%";
  int textW = percentText.length() * 12;
  int textX = battX + (battW - textW) / 2;
  int textY = battY + (battH - 16) / 2;
  
  display.setTextColor(SSD1306_BLACK);
  display.setCursor(textX + 2, textY + 2);
  display.print(percentText);
  
  display.fillRect(textX - 4, textY - 2, textW + 8, 18, SSD1306_BLACK);
  display.drawRect(textX - 4, textY - 2, textW + 8, 18, SSD1306_WHITE);
  
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(textX, textY);
  display.print(percentText);
  
  display.setTextSize(1);
  display.drawLine(0, 52, SCREEN_WIDTH, 52, SSD1306_WHITE);
  
  display.setCursor(2, 54);
  display.print(batteryVoltage, 2);
  display.print("V");
  
  display.setCursor(45, 54);
  if (isCharging) {
    int chargeFrame = (millis() / 300) % 4;
    display.print("CHG");
    for (int i = 0; i < chargeFrame; i++) {
      display.print(".");
    }
    
    int iconX = 78;
    int iconY = 54;
    if ((millis() / 200) % 2 == 0) {
      display.fillTriangle(iconX, iconY, iconX + 2, iconY + 4, iconX, iconY + 4, SSD1306_WHITE);
      display.fillTriangle(iconX, iconY + 4, iconX + 2, iconY + 8, iconX, iconY + 8, SSD1306_WHITE);
    }
  } else {
    if (batteryPercent > 80) display.print("FULL");
    else if (batteryPercent > 50) display.print("GOOD");
    else if (batteryPercent > 20) display.print("LOW");
    else {
      if ((millis() / 300) % 2 == 0) {
        display.print("CRITICAL!");
      }
    }
  }
  
  int healthBarX = 95;
  int healthBarY = 54;
  int healthBarW = 30;
  int healthBarH = 8;
  
  display.drawRect(healthBarX, healthBarY, healthBarW, healthBarH, SSD1306_WHITE);
  int healthFill = map(batteryPercent, 0, 100, 0, healthBarW - 2);
  
  for (int i = 0; i < healthFill; i += 2) {
    display.drawLine(healthBarX + 1 + i, healthBarY + 1, 
                    healthBarX + 1 + i, healthBarY + healthBarH - 2, SSD1306_WHITE);
  }
  
  display.display();
}

void showPowerStats() {
  display.clearDisplay();
  
  display.setTextSize(1);
  display.setCursor(5, 2);
  display.print("== POWER STATS ==");
  
  display.drawRect(2, 12, 124, 50, SSD1306_WHITE);
  
  display.setCursor(6, 16);
  display.print("Voltage:");
  display.setCursor(70, 16);
  display.print(batteryVoltage, 3);
  display.print(" V");
  
  display.setCursor(6, 26);
  display.print("Battery:");
  display.setCursor(70, 26);
  display.print(batteryPercent);
  display.print(" %");
  
  display.setCursor(6, 36);
  display.print("Status:");
  display.setCursor(70, 36);
  if (isCharging) {
    display.print("CHARGING");
    int x = 110;
    int y = 36;
    if ((millis() / 200) % 2 == 0) {
      display.fillTriangle(x, y, x+2, y+4, x, y+4, SSD1306_WHITE);
      display.fillTriangle(x, y+4, x+2, y+8, x, y+8, SSD1306_WHITE);
    }
  } else {
    if (batteryPercent > 80) display.print("EXCELLENT");
    else if (batteryPercent > 50) display.print("GOOD");
    else if (batteryPercent > 20) display.print("LOW");
    else display.print("CRITICAL!");
  }
  
  display.setCursor(6, 46);
  display.print("Est.Time:");
  display.setCursor(70, 46);
  if (isCharging) {
    int timeToFull = (100 - batteryPercent) * 2;
    display.print(timeToFull);
    display.print(" min");
  } else {
    int timeLeft = batteryPercent * 30;
    int hours = timeLeft / 60;
    int mins = timeLeft % 60;
    display.print(hours);
    display.print("h ");
    display.print(mins);
    display.print("m");
  }
  
  display.display();
}

void showPowerGraph() {
  display.clearDisplay();
  
  display.setTextSize(1);
  display.setCursor(15, 2);
  display.print("BATTERY GRAPH");
  
  int graphX = 10;
  int graphY = 15;
  int graphW = 108;
  int graphH = 40;
  
  display.drawLine(graphX, graphY, graphX, graphY + graphH, SSD1306_WHITE);
  display.drawLine(graphX, graphY + graphH, graphX + graphW, graphY + graphH, SSD1306_WHITE);
  
  display.setTextSize(1);
  display.setCursor(2, graphY - 2);
  display.print("100");
  display.setCursor(2, graphY + graphH/2 - 2);
  display.print("50");
  display.setCursor(2, graphY + graphH - 6);
  display.print("0");
  
  for (int i = 0; i <= 4; i++) {
    int y = graphY + (graphH * i / 4);
    for (int x = graphX; x < graphX + graphW; x += 4) {
      display.drawPixel(x, y, SSD1306_WHITE);
    }
  }
  
  int dataPoints = historyFilled ? POWER_HISTORY_SIZE : historyIndex;
  if (dataPoints > 1) {
    int startIdx = historyFilled ? historyIndex : 0;
    
    for (int i = 0; i < dataPoints - 1; i++) {
      int idx1 = (startIdx + i) % POWER_HISTORY_SIZE;
      int idx2 = (startIdx + i + 1) % POWER_HISTORY_SIZE;
      
      int x1 = graphX + (i * graphW / (dataPoints - 1));
      int y1 = graphY + graphH - (batteryHistory[idx1] * graphH / 100);
      int x2 = graphX + ((i + 1) * graphW / (dataPoints - 1));
      int y2 = graphY + graphH - (batteryHistory[idx2] * graphH / 100);
      
      display.drawLine(x1, y1, x2, y2, SSD1306_WHITE);
      display.fillCircle(x1, y1, 1, SSD1306_WHITE);
    }
    
    int lastIdx = historyFilled ? (historyIndex - 1 + POWER_HISTORY_SIZE) % POWER_HISTORY_SIZE : historyIndex - 1;
    int lastX = graphX + ((dataPoints - 1) * graphW / (dataPoints - 1));
    int lastY = graphY + graphH - (batteryHistory[lastIdx] * graphH / 100);
    
    if ((millis() / 300) % 2 == 0) {
      display.fillCircle(lastX, lastY, 2, SSD1306_WHITE);
    }
  }
  
  display.setCursor(40, 58);
  display.print("Now: ");
  display.print(batteryPercent);
  display.print("%");
  
  if (isCharging) {
    display.setCursor(90, 58);
    int anim = (millis() / 300) % 3;
    display.print("CHG");
    for (int i = 0; i < anim; i++) {
      display.print(".");
    }
  }
  
  display.display();
}

void showAPISelect() {
  display.clearDisplay();
  
  display.setTextSize(1);
  display.setCursor(15, 5);
  display.print("SELECT GEMINI API");
  
  display.drawLine(0, 15, SCREEN_WIDTH, 15, SSD1306_WHITE);
  
  int y1 = 25;
  if (menuSelection == 0) {
    display.fillRect(5, y1 - 2, 118, 12, SSD1306_WHITE);
    display.setTextColor(SSD1306_BLACK);
  }
  display.setCursor(10, y1);
  display.print("1. Gemini API #1");
  if (selectedAPIKey == 1) {
    display.setCursor(100, y1);
    display.print("[*]");
  }
  display.setTextColor(SSD1306_WHITE);
  
  int y2 = 42;
  if (menuSelection == 1) {
    display.fillRect(5, y2 - 2, 118, 12, SSD1306_WHITE);
    display.setTextColor(SSD1306_BLACK);
  }
  display.setCursor(10, y2);
  display.print("2. Gemini API #2");
  if (selectedAPIKey == 2) {
    display.setCursor(100, y2);
    display.print("[*]");
  }
  display.setTextColor(SSD1306_WHITE);
  
  if ((millis() / 300) % 2 == 0) {
    int arrowY = menuSelection == 0 ? y1 : y2;
    display.fillTriangle(2, arrowY + 2, 2, arrowY + 6, 5, arrowY + 4, SSD1306_WHITE);
  }
  
  display.display();
}

void showCalculator() {
  display.clearDisplay();
  drawBatteryIndicator();
  
  display.setTextSize(1);
  display.setCursor(0, 10);
  display.println("=== CALCULATOR ===");
  
  display.drawRect(2, 20, SCREEN_WIDTH - 4, 12, SSD1306_WHITE);
  display.setCursor(6, 23);
  String displayText = calcDisplay;
  if (displayText.length() > 18) {
    displayText = displayText.substring(displayText.length() - 18);
  }
  display.print(displayText);
  
  const char* calcPad[4][4] = {
    {"7", "8", "9", "/"},
    {"4", "5", "6", "*"},
    {"1", "2", "3", "-"},
    {"C", "0", "=", "+"}
  };
  
  int startY = 36;
  for (int row = 0; row < 4; row++) {
    for (int col = 0; col < 4; col++) {
      int x = col * 30 + 4;
      int y = startY + row * 7;
      
      if (row == cursorY && col == cursorX) {
        display.fillRect(x - 2, y - 1, 16, 8, SSD1306_WHITE);
        display.setTextColor(SSD1306_BLACK);
      } else {
        display.setTextColor(SSD1306_WHITE);
      }
      
      display.setCursor(x, y);
      display.print(calcPad[row][col]);
    }
  }
  
  display.setTextColor(SSD1306_WHITE);
  display.display();
}

void handleCalculatorInput() {
  const char* calcPad[4][4] = {
    {"7", "8", "9", "/"},
    {"4", "5", "6", "*"},
    {"1", "2", "3", "-"},
    {"C", "0", "=", "+"}
  };
  
  String key = calcPad[cursorY][cursorX];
  
  if (key == "C") {
    resetCalculator();
  } else if (key == "=") {
    calculateResult();
  } else if (key == "+" || key == "-" || key == "*" || key == "/") {
    if (calcDisplay != "0" && calcDisplay != "Error") {
      calcNumber1 = calcDisplay;
      calcOperator = key.charAt(0);
      calcNewNumber = true;
    }
  } else {
    if (calcNewNumber || calcDisplay == "0" || calcDisplay == "Error") {
      calcDisplay = key;
      calcNewNumber = false;
    } else {
      if (calcDisplay.length() < 12) {
        calcDisplay += key;
      }
    }
  }
  
  showCalculator();
}

void calculateResult() {
  if (calcNumber1.length() > 0 && calcOperator != ' ') {
    float num1 = calcNumber1.toFloat();
    float num2 = calcDisplay.toFloat();
    float result = 0;
    
    switch(calcOperator) {
      case '+': result = num1 + num2; break;
      case '-': result = num1 - num2; break;
      case '*': result = num1 * num2; break;
      case '/':
        if (num2 != 0) {
          result = num1 / num2;
        } else {
          ledError();
          calcDisplay = "Error";
          calcNumber1 = "";
          calcOperator = ' ';
          calcNewNumber = true;
          return;
        }
        break;
    }
    
    ledSuccess();
    
    calcDisplay = String(result, 2);
    while (calcDisplay.endsWith("0") && calcDisplay.indexOf('.') != -1) {
      calcDisplay.remove(calcDisplay.length() - 1);
    }
    if (calcDisplay.endsWith(".")) {
      calcDisplay.remove(calcDisplay.length() - 1);
    }
    
    calcNumber1 = "";
    calcOperator = ' ';
    calcNewNumber = true;
  }
}

void resetCalculator() {
  calcDisplay = "0";
  calcNumber1 = "";
  calcOperator = ' ';
  calcNewNumber = true;
}

void showLoadingAnimation() {
  display.clearDisplay();
  drawBatteryIndicator();
  
  display.setTextSize(1);
  display.setCursor(20, 10);
  display.print("Loading AI");
  
  int dots = (loadingFrame % 4);
  for (int i = 0; i < dots; i++) {
    display.print(".");
  }
  
  int centerX = SCREEN_WIDTH / 2;
  int centerY = 35;
  int radius = 12;
  
  display.drawCircle(centerX, centerY, radius, SSD1306_WHITE);
  
  float angle = loadingFrame * PI / 4;
  int x2 = centerX + cos(angle) * radius;
  int y2 = centerY + sin(angle) * radius;
  
  display.drawLine(centerX, centerY, x2, y2, SSD1306_WHITE);
  display.fillCircle(centerX, centerY, 3, SSD1306_WHITE);
  
  display.setCursor(25, 52);
  display.print("Gemini API #");
  display.print(selectedAPIKey);
  
  display.display();
}

void handleUp() {
  switch(currentState) {
    case STATE_MAIN_MENU:
      menuSelection = (menuSelection - 1 + 5) % 5;
      showMainMenu();
      break;
    case STATE_WIFI_MENU:
      menuSelection = (menuSelection - 1 + 3) % 3;
      showWiFiMenu();
      break;
    case STATE_POWER_BASE:
      powerMenuSelection = (powerMenuSelection - 1 + 4) % 4;
      showPowerBase();
      break;
    case STATE_SETTINGS_MENU:
      settingsMenuSelection = (settingsMenuSelection - 1 + 4) % 4;
      showSettingsMenu();
      break;
    case STATE_API_SELECT:
      menuSelection = (menuSelection - 1 + 2) % 2;
      showAPISelect();
      break;
    case STATE_WIFI_SCAN:
      if (networkCount > 0) {
        selectedNetwork = (selectedNetwork - 1 + networkCount) % networkCount;
        displayWiFiNetworks();
      }
      break;
    case STATE_KEYBOARD:
    case STATE_PASSWORD_INPUT:
      cursorY = (cursorY - 1 + 3) % 3;
      drawKeyboard();
      break;
    case STATE_CALCULATOR:
      cursorY = (cursorY - 1 + 4) % 4;
      showCalculator();
      break;
    case STATE_CHAT_RESPONSE:
      scrollOffset = max(0, scrollOffset - 8);
      displayResponse();
      break;
  }
}

void handleDown() {
  switch(currentState) {
    case STATE_MAIN_MENU:
      menuSelection = (menuSelection + 1) % 5;
      showMainMenu();
      break;
    case STATE_WIFI_MENU:
      menuSelection = (menuSelection + 1) % 3;
      showWiFiMenu();
      break;
    case STATE_POWER_BASE:
      powerMenuSelection = (powerMenuSelection + 1) % 4;
      showPowerBase();
      break;
    case STATE_SETTINGS_MENU:
      settingsMenuSelection = (settingsMenuSelection + 1) % 4;
      showSettingsMenu();
      break;
    case STATE_API_SELECT:
      menuSelection = (menuSelection + 1) % 2;
      showAPISelect();
      break;
    case STATE_WIFI_SCAN:
      if (networkCount > 0) {
        selectedNetwork = (selectedNetwork + 1) % networkCount;
        displayWiFiNetworks();
      }
      break;
    case STATE_KEYBOARD:
    case STATE_PASSWORD_INPUT:
      cursorY = (cursorY + 1) % 3;
      drawKeyboard();
      break;
    case STATE_CALCULATOR:
      cursorY = (cursorY + 1) % 4;
      showCalculator();
      break;
    case STATE_CHAT_RESPONSE:
      scrollOffset += 8;
      displayResponse();
      break;
  }
}

void handleLeft() {
  switch(currentState) {
    case STATE_KEYBOARD:
    case STATE_PASSWORD_INPUT:
      cursorX = (cursorX - 1 + 10) % 10;
      drawKeyboard();
      break;
    case STATE_CALCULATOR:
      cursorX = (cursorX - 1 + 4) % 4;
      showCalculator();
      break;
  }
}

void handleRight() {
  switch(currentState) {
    case STATE_KEYBOARD:
    case STATE_PASSWORD_INPUT:
      cursorX = (cursorX + 1) % 10;
      drawKeyboard();
      break;
    case STATE_CALCULATOR:
      cursorX = (cursorX + 1) % 4;
      showCalculator();
      break;
  }
}

void handleSelect() {
  switch(currentState) {
    case STATE_MAIN_MENU:
      handleMainMenuSelect();
      break;
    case STATE_WIFI_MENU:
      handleWiFiMenuSelect();
      break;
    case STATE_POWER_BASE:
      handlePowerBaseSelect();
      break;
    case STATE_POWER_VISUAL:
    case STATE_POWER_STATS:
    case STATE_POWER_GRAPH:
      currentState = STATE_POWER_BASE;
      powerMenuSelection = 0;
      showPowerBase();
      break;
    case STATE_SETTINGS_MENU:
      handleSettingsMenuSelect();
      break;
    case STATE_SYSTEM_INFO:
      currentState = STATE_SETTINGS_MENU;
      settingsMenuSelection = 0;
      showSettingsMenu();
      break;
    case STATE_SLEEP_MENU:
      enterDeepSleep();
      break;
    case STATE_API_SELECT:
      handleAPISelectSelect();
      break;
    case STATE_CALCULATOR:
      handleCalculatorInput();
      break;
    case STATE_WIFI_SCAN:
      if (networkCount > 0) {
        selectedSSID = networks[selectedNetwork].ssid;
        if (networks[selectedNetwork].encrypted) {
          passwordInput = "";
          currentState = STATE_PASSWORD_INPUT;
          cursorX = 0;
          cursorY = 0;
          currentKeyboardMode = MODE_LOWER;
          drawKeyboard();
        } else {
          connectToWiFi(selectedSSID, "");
        }
      }
      break;
    case STATE_KEYBOARD:
      handleKeyPress();
      break;
    case STATE_PASSWORD_INPUT:
      handlePasswordKeyPress();
      break;
    case STATE_CHAT_RESPONSE:
      currentState = STATE_MAIN_MENU;
      userInput = "";
      aiResponse = "";
      scrollOffset = 0;
      showMainMenu();
      break;
  }
}

void showMainMenu() {
  display.clearDisplay();
  drawBatteryIndicator();
  
  if (WiFi.status() == WL_CONNECTED) {
    drawWiFiSignalBars();
  }
  
  display.setTextSize(1);
  
  const char* menuItems[] = {
    "1. Chat AI",
    "2. WiFi Settings",
    "3. Calculator",
    "4. Power Central",
    "5. Settings"
  };
  
  int startY = 10;
  
  for (int i = 0; i < 5; i++) {
    display.setCursor(2, startY + i * 10);
    if (i == menuSelection) {
      display.print("> ");
      if ((millis() / 200) % 2 == 0) {
        display.fillRect(SCREEN_WIDTH - 6, startY + i * 10, 4, 8, SSD1306_WHITE);
      }
    } else {
      display.print("  ");
    }
    display.print(menuItems[i]);
  }
  
  display.display();
}

void handleMainMenuSelect() {
  switch(menuSelection) {
    case 0:
      if (WiFi.status() == WL_CONNECTED) {
        menuSelection = 0;
        currentState = STATE_API_SELECT;
        showAPISelect();
      } else {
        ledError();
        showStatus("WiFi not connected!\nGo to WiFi Settings", 2000);
        showMainMenu();
      }
      break;
    case 1:
      menuSelection = 0;
      currentState = STATE_WIFI_MENU;
      showWiFiMenu();
      break;
    case 2:
      resetCalculator();
      currentState = STATE_CALCULATOR;
      cursorX = 0;
      cursorY = 0;
      showCalculator();
      break;
    case 3:
      powerMenuSelection = 0;
      currentState = STATE_POWER_BASE;
      showPowerBase();
      break;
    case 4:
      settingsMenuSelection = 0;
      currentState = STATE_SETTINGS_MENU;
      showSettingsMenu();
      break;
  }
}

void handlePowerBaseSelect() {
  switch(powerMenuSelection) {
    case 0:
      currentState = STATE_POWER_VISUAL;
      showPowerVisual();
      break;
    case 1:
      currentState = STATE_POWER_STATS;
      showPowerStats();
      break;
    case 2:
      currentState = STATE_POWER_GRAPH;
      showPowerGraph();
      break;
    case 3:
      currentState = STATE_MAIN_MENU;
      menuSelection = 0;
      showMainMenu();
      break;
  }
}

void handleAPISelectSelect() {
  if (menuSelection == 0) {
    selectedAPIKey = 1;
  } else {
    selectedAPIKey = 2;
  }
  
  ledSuccess();
  
  userInput = "";
  currentState = STATE_KEYBOARD;
  cursorX = 0;
  cursorY = 0;
  currentKeyboardMode = MODE_LOWER;
  drawKeyboard();
}

void showWiFiMenu() {
  display.clearDisplay();
  drawBatteryIndicator();
  
  display.setTextSize(1);
  display.setCursor(5, 10);
  display.println("=== WiFi MENU ===");
  
  display.setCursor(5, 20);
  if (WiFi.status() == WL_CONNECTED) {
    display.print("Connected:");
    display.setCursor(5, 28);
    String ssid = WiFi.SSID();
    if (ssid.length() > 18) {
      ssid = ssid.substring(0, 18) + "..";
    }
    display.print(ssid);
  } else {
    display.print("Not connected");
  }
  
  const char* menuItems[] = {"Scan Networks", "Forget Network", "Back"};
  
  for (int i = 0; i < 3; i++) {
    display.setCursor(5, 40 + i * 8);
    if (i == menuSelection) {
      display.print("> ");
    } else {
      display.print("  ");
    }
    display.print(menuItems[i]);
  }
  
  display.display();
}

void handleWiFiMenuSelect() {
  switch(menuSelection) {
    case 0:
      scanWiFiNetworks();
      break;
    case 1:
      forgetNetwork();
      break;
    case 2:
      menuSelection = 0;
      currentState = STATE_MAIN_MENU;
      showMainMenu();
      break;
  }
}

void scanWiFiNetworks() {
  showProgressBar("Scanning", 0);
  
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  delay(100);
  
  showProgressBar("Scanning", 30);
  
  int n = WiFi.scanNetworks();
  networkCount = min(n, 20);
  
  showProgressBar("Processing", 60);
  
  for (int i = 0; i < networkCount; i++) {
    networks[i].ssid = WiFi.SSID(i);
    networks[i].rssi = WiFi.RSSI(i);
    networks[i].encrypted = (WiFi.encryptionType(i) != WIFI_AUTH_OPEN);
  }
  
  showProgressBar("Sorting", 80);
  
  for (int i = 0; i < networkCount - 1; i++) {
    for (int j = i + 1; j < networkCount; j++) {
      if (networks[j].rssi > networks[i].rssi) {
        WiFiNetwork temp = networks[i];
        networks[i] = networks[j];
        networks[j] = temp;
      }
    }
  }
  
  showProgressBar("Complete", 100);
  delay(500);
  
  selectedNetwork = 0;
  currentState = STATE_WIFI_SCAN;
  displayWiFiNetworks();
}

void displayWiFiNetworks() {
  display.clearDisplay();
  drawBatteryIndicator();
  
  display.setTextSize(1);
  display.setCursor(5, 0);
  display.print("WiFi (");
  display.print(networkCount);
  display.print(" found)");
  
  display.drawLine(0, 10, SCREEN_WIDTH, 10, SSD1306_WHITE);
  
  if (networkCount == 0) {
    display.setCursor(10, 25);
    display.println("No networks found");
  } else {
    int startIdx = max(0, selectedNetwork - 1);
    int endIdx = min(networkCount, startIdx + 4);
    
    for (int i = startIdx; i < endIdx; i++) {
      int y = 12 + (i - startIdx) * 12;
      
      if (i == selectedNetwork) {
        display.fillRect(0, y, SCREEN_WIDTH, 11, SSD1306_WHITE);
        display.setTextColor(SSD1306_BLACK);
      } else {
        display.setTextColor(SSD1306_WHITE);
      }
      
      display.setCursor(2, y + 2);
      
      String displaySSID = networks[i].ssid;
      if (displaySSID.length() > 15) {
        displaySSID = displaySSID.substring(0, 15) + "..";
      }
      display.print(displaySSID);
      
      display.setCursor(110, y + 2);
      int bars = map(networks[i].rssi, -100, -50, 1, 4);
      bars = constrain(bars, 1, 4);
      for (int b = 0; b < bars; b++) {
        display.print("|");
      }
      
      if (networks[i].encrypted) {
        display.setCursor(100, y + 2);
        display.print("L");
      }
      
      display.setTextColor(SSD1306_WHITE);
    }
  }
  
  display.display();
}

void handlePasswordKeyPress() {
  const char* key = getCurrentKey();
  
  if (strcmp(key, "OK") == 0) {
    if (passwordInput.length() > 0 || !networks[selectedNetwork].encrypted) {
      connectToWiFi(selectedSSID, passwordInput);
    } else {
      showStatus("Password required!", 1500);
      drawKeyboard();
    }
  } else if (strcmp(key, "<") == 0) {
    if (passwordInput.length() > 0) {
      passwordInput.remove(passwordInput.length() - 1);
    }
    drawKeyboard();
  } else if (strcmp(key, "#") == 0) {
    toggleKeyboardMode();
    drawKeyboard();
  } else {
    passwordInput += key;
    if (currentKeyboardMode == MODE_UPPER) {
      currentKeyboardMode = MODE_LOWER;
    }
    drawKeyboard();
  }
}

void connectToWiFi(String ssid, String password) {
  showProgressBar("Connecting", 0);
  
  WiFi.disconnect();
  delay(100);
  WiFi.begin(ssid.c_str(), password.c_str());
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    ledBlink(100);
    delay(500);
    Serial.print(".");
    attempts++;
    
    showProgressBar("Connecting", attempts * 3);
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    preferences.putString("ssid", ssid);
    preferences.putString("password", password);
    
    ledSuccess();
    showProgressBar("Connected!", 100);
    delay(1000);
    
    lastWiFiActivity = millis();
    
    currentState = STATE_MAIN_MENU;
    menuSelection = 0;
    showMainMenu();
  } else {
    ledError();
    showStatus("Connection failed!\nWrong password?", 2000);
    
    currentState = STATE_WIFI_SCAN;
    displayWiFiNetworks();
  }
}

void forgetNetwork() {
  preferences.clear();
  WiFi.disconnect();
  showStatus("Network forgotten!", 2000);
  showWiFiMenu();
}

const char* getCurrentKey() {
  switch(currentKeyboardMode) {
    case MODE_LOWER:
      return keyboardLower[cursorY][cursorX];
    case MODE_UPPER:
      return keyboardUpper[cursorY][cursorX];
    case MODE_NUMBERS:
      return keyboardNumbers[cursorY][cursorX];
    default:
      return keyboardLower[cursorY][cursorX];
  }
}

void toggleKeyboardMode() {
  switch(currentKeyboardMode) {
    case MODE_LOWER:
      currentKeyboardMode = MODE_UPPER;
      break;
    case MODE_UPPER:
      currentKeyboardMode = MODE_NUMBERS;
      break;
    case MODE_NUMBERS:
      currentKeyboardMode = MODE_LOWER;
      break;
  }
}

void drawKeyboard() {
  display.clearDisplay();
  drawBatteryIndicator();
  
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  
  if (currentState == STATE_PASSWORD_INPUT) {
    display.print("Pass:");
    String masked = "";
    for (unsigned int i = 0; i < passwordInput.length(); i++) {
      masked += "*";
    }
    String displayText = masked.substring(max(0, (int)masked.length() - 10));
    display.print(displayText);
  } else {
    display.print(">");
    String displayText = userInput.substring(max(0, (int)userInput.length() - 14));
    display.print(displayText);
  }
  
  display.setCursor(SCREEN_WIDTH - 18, 0);
  if (currentKeyboardMode == MODE_UPPER) {
    display.print("A");
  } else if (currentKeyboardMode == MODE_NUMBERS) {
    display.print("#");
  } else {
    display.print("a");
  }
  
  display.drawLine(0, 10, SCREEN_WIDTH, 10, SSD1306_WHITE);
  
  int startY = 14;
  const char* currentKeyboard[3][10];
  
  switch(currentKeyboardMode) {
    case MODE_LOWER:
      memcpy(currentKeyboard, keyboardLower, sizeof(keyboardLower));
      break;
    case MODE_UPPER:
      memcpy(currentKeyboard, keyboardUpper, sizeof(keyboardUpper));
      break;
    case MODE_NUMBERS:
      memcpy(currentKeyboard, keyboardNumbers, sizeof(keyboardNumbers));
      break;
  }
  
  for (int row = 0; row < 3; row++) {
    for (int col = 0; col < 10; col++) {
      int x = col * 12 + 2;
      int y = startY + row * 16;
      
      if (row == cursorY && col == cursorX) {
        display.fillRect(x - 1, y - 1, 11, 10, SSD1306_WHITE);
        display.setTextColor(SSD1306_BLACK);
      } else {
        display.setTextColor(SSD1306_WHITE);
      }
      
      display.setCursor(x, y);
      
      const char* key = currentKeyboard[row][col];
      
      if (strcmp(key, "OK") == 0) {
        display.print("OK");
      } else if (strcmp(key, "<") == 0) {
        display.print("<");
      } else if (strcmp(key, "#") == 0) {
        display.print("#");
      } else if (strcmp(key, " ") == 0) {
        display.print("_");
      } else {
        display.print(key);
      }
    }
  }
  
  display.display();
}

void handleKeyPress() {
  const char* key = getCurrentKey();
  
  if (strcmp(key, "OK") == 0) {
    if (userInput.length() > 0) {
      if (userInput.length() > 200) {
        showStatus("Input too long!\nMax 200 chars", 2000);
        drawKeyboard();
        return;
      }
      
      sendToGemini();
    } else {
      showStatus("Type something\nfirst!", 1500);
      drawKeyboard();
    }
  } else if (strcmp(key, "<") == 0) {
    if (userInput.length() > 0) {
      userInput.remove(userInput.length() - 1);
    }
    drawKeyboard();
  } else if (strcmp(key, "#") == 0) {
    toggleKeyboardMode();
    drawKeyboard();
  } else {
    userInput += key;
    
    if (currentKeyboardMode == MODE_UPPER) {
      currentKeyboardMode = MODE_LOWER;
    }
    
    drawKeyboard();
  }
}

void sendToGemini() {
  currentState = STATE_LOADING;
  loadingFrame = 0;
  lastLoadingUpdate = millis();
  
  for (int i = 0; i < 5; i++) {
    showLoadingAnimation();
    delay(100);
    loadingFrame++;
  }
  
  if (WiFi.status() != WL_CONNECTED) {
    ledError();
    aiResponse = "WiFi not connected!";
    currentState = STATE_CHAT_RESPONSE;
    scrollOffset = 0;
    displayResponse();
    return;
  }
  
  const char* currentApiKey = (selectedAPIKey == 1) ? geminiApiKey1 : geminiApiKey2;
  
  if (strlen(currentApiKey) < 10) {
    ledError();
    aiResponse = "API Key #" + String(selectedAPIKey) + " not set! Get it from aistudio.google.com";
    currentState = STATE_CHAT_RESPONSE;
    scrollOffset = 0;
    displayResponse();
    return;
  }
  
  HTTPClient http;
  String url = String(geminiEndpoint) + "?key=" + currentApiKey;
  
  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(15000);
  
  String escapedInput = userInput;
  escapedInput.replace("\\", "\\\\");
  escapedInput.replace("\"", "\\\"");
  escapedInput.replace("\n", "\\n");
  
  String jsonPayload = "{\"contents\":[{\"parts\":[{\"text\":\"" + escapedInput + "\"}]}]}";
  
  int httpResponseCode = http.POST(jsonPayload);
  
  if (httpResponseCode == 200) {
    String response = http.getString();
    
    StaticJsonDocument<16384> responseDoc;
    DeserializationError error = deserializeJson(responseDoc, response);
    
    if (!error && responseDoc.containsKey("candidates")) {
      JsonArray candidates = responseDoc["candidates"];
      if (candidates.size() > 0) {
        JsonObject content = candidates[0]["content"];
        JsonArray parts = content["parts"];
        if (parts.size() > 0) {
          aiResponse = parts[0]["text"].as<String>();
          ledSuccess();
        } else {
          aiResponse = "Error: Empty response";
        }
      } else {
        aiResponse = "Error: No candidates";
      }
    } else {
      ledError();
      aiResponse = "JSON Error";
    }
  } else {
    ledError();
    aiResponse = "HTTP Error " + String(httpResponseCode);
  }
  
  http.end();
  
  lastWiFiActivity = millis();
  
  currentState = STATE_CHAT_RESPONSE;
  scrollOffset = 0;
  displayResponse();
}

void displayResponse() {
  display.clearDisplay();
  drawBatteryIndicator();
  
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  
  if (aiResponse.length() == 0) {
    display.setCursor(0, 25);
    display.println("No response");
    display.display();
    return;
  }
  
  int y = 12 - scrollOffset;
  int lineHeight = 10;
  String word = "";
  int x = 0;
  
  for (unsigned int i = 0; i < aiResponse.length(); i++) {
    char c = aiResponse.charAt(i);
    
    if (c == ' ' || c == '\n' || i == aiResponse.length() - 1) {
      if (i == aiResponse.length() - 1 && c != ' ' && c != '\n') {
        word += c;
      }
      
      int wordWidth = word.length() * 6;
      
      if (x + wordWidth > SCREEN_WIDTH - 10) {
        y += lineHeight;
        x = 0;
      }
      
      if (y >= -lineHeight && y < SCREEN_HEIGHT) {
        display.setCursor(x, y);
        display.print(word);
      }
      
      x += wordWidth + 6;
      word = "";
      
      if (c == '\n') {
        y += lineHeight;
        x = 0;
      }
    } else {
      word += c;
    }
  }
  
  int totalHeight = y + lineHeight;
  if (totalHeight > SCREEN_HEIGHT) {
    display.drawLine(126, 0, 126, SCREEN_HEIGHT - 1, SSD1306_WHITE);
    int scrollBarHeight = max(8, SCREEN_HEIGHT * SCREEN_HEIGHT / totalHeight);
    int maxScroll = totalHeight - SCREEN_HEIGHT;
    int scrollBarPos = map(scrollOffset, 0, maxScroll, 0, SCREEN_HEIGHT - scrollBarHeight);
    display.fillRect(126, scrollBarPos, 2, scrollBarHeight, SSD1306_WHITE);
  }
  
  display.display();
}

void showStatus(String message, int delayMs) {
  display.clearDisplay();
  display.setTextSize(1);
  
  int y = 20;
  int x = 0;
  String word = "";
  
  for (unsigned int i = 0; i < message.length(); i++) {
    char c = message.charAt(i);
    
    if (c == '\n') {
      display.setCursor(x, y);
      display.print(word);
      word = "";
      y += 10;
      x = 0;
    } else if (c == ' ') {
      word += c;
      int wordWidth = word.length() * 6;
      if (x + wordWidth > SCREEN_WIDTH) {
        y += 10;
        x = 0;
      }
      display.setCursor(x, y);
      display.print(word);
      x += wordWidth;
      word = "";
    } else {
      word += c;
    }
  }
  
  if (word.length() > 0) {
    display.setCursor(x, y);
    display.print(word);
  }
  
  display.display();
  delay(delayMs);
}

void refreshCurrentScreen() {
  switch(currentState) {
    case STATE_MAIN_MENU:
      showMainMenu();
      break;
    case STATE_WIFI_MENU:
      showWiFiMenu();
      break;
    case STATE_CALCULATOR:
      showCalculator();
      break;
    case STATE_POWER_BASE:
      showPowerBase();
      break;
    case STATE_POWER_VISUAL:
      showPowerVisual();
      break;
    case STATE_POWER_STATS:
      showPowerStats();
      break;
    case STATE_POWER_GRAPH:
      showPowerGraph();
      break;
    case STATE_API_SELECT:
      showAPISelect();
      break;
    case STATE_SYSTEM_INFO:
      showSystemInfo();
      break;
    case STATE_SETTINGS_MENU:
      showSettingsMenu();
      break;
    case STATE_SLEEP_MENU:
      showSleepMenu();
      break;
    case STATE_WIFI_SCAN:
      displayWiFiNetworks();
      break;
    case STATE_KEYBOARD:
    case STATE_PASSWORD_INPUT:
      drawKeyboard();
      break;
    case STATE_CHAT_RESPONSE:
      displayResponse();
      break;
  }
}

void updateBatteryLevel() {
  int adcSum = 0;
  for (int i = 0; i < 10; i++) {
    adcSum += analogRead(BATTERY_PIN);
    delay(5);
  }
  int adcValue = adcSum / 10;
  
  float adcVoltage = (adcValue / 4095.0) * 3.3;
  batteryVoltage = adcVoltage * VOLTAGE_DIVIDER_RATIO;
  
  batteryPercent = map(batteryVoltage * 100, BATTERY_MIN_VOLTAGE * 100, BATTERY_MAX_VOLTAGE * 100, 0, 100);
  batteryPercent = constrain(batteryPercent, 0, 100);
  
  int chargingSum = 0;
  for (int i = 0; i < 5; i++) {
    chargingSum += analogRead(CHARGING_PIN);
    delay(2);
  }
  int chargingValue = chargingSum / 5;
  float chargingVoltage = (chargingValue / 4095.0) * 3.3 * VOLTAGE_DIVIDER_RATIO;
  
  isCharging = (chargingVoltage > batteryVoltage + 0.3);
}

void drawBatteryIndicator() {
  int battX = SCREEN_WIDTH - 24;
  int battY = 1;
  int battWidth = 22;
  int battHeight = 8;
  
  display.drawRect(battX, battY, battWidth, battHeight, SSD1306_WHITE);
  display.fillRect(battX + battWidth, battY + 2, 2, battHeight - 4, SSD1306_WHITE);
  
  int fillWidth = map(batteryPercent, 0, 100, 0, battWidth - 4);
  
  if (batteryPercent > 20) {
    display.fillRect(battX + 2, battY + 2, fillWidth, battHeight - 4, SSD1306_WHITE);
  } else if (batteryPercent > 10) {
    if ((millis() / 500) % 2 == 0) {
      display.fillRect(battX + 2, battY + 2, fillWidth, battHeight - 4, SSD1306_WHITE);
    }
  } else {
    if ((millis() / 250) % 2 == 0) {
      display.fillRect(battX + 2, battY + 2, fillWidth, battHeight - 4, SSD1306_WHITE);
    }
  }
  
  display.setTextSize(1);
  
  String percentText = String(batteryPercent);
  int textWidth = percentText.length() * 6;
  int textX = battX + (battWidth - textWidth) / 2;
  int textY = battY + 1;
  
  if (batteryPercent > 50) {
    display.setTextColor(SSD1306_BLACK);
  } else {
    display.setTextColor(SSD1306_WHITE);
  }
  
  display.setCursor(textX, textY);
  display.print(batteryPercent);
  
  if (isCharging) {
    drawChargingPlug();
  }
  
  display.setTextColor(SSD1306_WHITE);
}

void drawChargingPlug() {
  int plugX = SCREEN_WIDTH - 35;
  int plugY = 2;
  
  int anim = (millis() / 200) % 2;
  
  display.drawLine(plugX, plugY, plugX, plugY + 2 + anim, SSD1306_WHITE);
  display.drawLine(plugX + 3, plugY, plugX + 3, plugY + 2 + anim, SSD1306_WHITE);
  
  display.drawRect(plugX - 1, plugY + 2, 5, 4, SSD1306_WHITE);
  display.drawLine(plugX + 1, plugY + 6, plugX + 1, plugY + 7, SSD1306_WHITE);
  
  if (anim == 1) {
    display.drawPixel(plugX - 2, plugY + 4, SSD1306_WHITE);
    display.drawPixel(plugX + 5, plugY + 3, SSD1306_WHITE);
  }
}

void drawWiFiSignalBars() {
  int rssi = WiFi.RSSI();
  int bars = 0;
  
  if (rssi > -50) bars = 4;
  else if (rssi > -60) bars = 3;
  else if (rssi > -70) bars = 2;
  else if (rssi > -80) bars = 1;
  
  int x = 2;
  int y = 2;
  
  for (int i = 0; i < 4; i++) {
    int barHeight = (i + 1) * 2;
    if (i < bars) {
      display.fillRect(x + i * 3, y + (8 - barHeight), 2, barHeight, SSD1306_WHITE);
    } else {
      display.drawRect(x + i * 3, y + (8 - barHeight), 2, barHeight, SSD1306_WHITE);
    }
  }
}
